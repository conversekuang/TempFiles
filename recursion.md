



递归：



非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过叫“归”。

所有的递归问题都可以用递推公式来表示。





递归需要满足的条件：

1. 一个问题的解可以分解为几个子问题的解

2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样

3. 存在递归终止条件




如何编写递推代码：

- 写出递推公式，找到终止条件

写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件，最后将递推公式和终止条件翻译成代码。





对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。



编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。



A = B+C+D

考虑BCD已经解决的基础上如何解决A，并且需要思考A与BCD之间的关系即可。



- 递归代码要警惕堆栈溢出

  函数调用会使用栈来保存临时变量，将临时变量封装成帧压入内存栈，等到函数执行完再返回出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，一直入栈操作，存在溢出风险。

- 递归代码要警惕重复计算

  为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的值。





- 在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成可观的时间成本。空间复杂度上内存栈需要保存每一次的现场数据，因此空间复杂度是O(n)





- 递归代码改为非递归代码：

  递归本身是借助栈实现的，若改为非递归写法还是要手动模拟入栈、出栈过程。本质不变，只是看上去不是递归代码的样子。





课后思考：

递归代码有什么好的调试方式？

- 打印日志发现递归值
- 结合条件断点进行调试



leetcode17题递归

```python
class Solution(object):
    dic_arr = {
   	"2":["a","b","c"],
   	"3":["d","e","f"],
   	"4":["g","h","i"],
   	"5":["j","k","l"],
   	"6":["m","n","o"],
   	"7":["p","q","r","s"],
   	"8":["t","u","v"],
   	"9":["w","x","y","z"],
   }
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        for i in digits:
        	if i not in self.dic_arr.keys():
        		return None 
        		
       	if len(digits) == 1:
       	    return self.dic_arr[digits]
       	else:
			results=[]
			res_arr = digits[1:len(digits)]	
			for i in self.dic_arr[str(digits[0])]:
				for j in self.letterCombinations(res_arr):
					results.append(i+j)
			return results
```

