

### shallow and deep copy



#### == 与is

- ==用于a,b两个变量的值是否相同； is表示对象是否相同，是否指向同一内存地址

对于整形数字，a is b为True的结论只适用于[-5，256]。因为处于性能优化，Python对[-5，256]的整形维持在一个数组，因此该范围的数组可以直接进行引用。对于该数组之外的数字，需要重新开辟空间，因此用is会发现是不同的对象。

```
>>> a=100
>>> b=100
>>> a == b
True
>>> id(a)
140713684692912
>>> id(b)
140713684692912
>>> a is b
True

>>> a = 1000
>>> b = 1000
>>> a == b
True
>>> id(a)
2173244295184
>>> id(b)
2173244295056
>>> a is b
False
```

- 一般情况下，应用场景== 比is更多

  - 在比较两个变量，更关系其值是否相同，而不是内存地址。

  - 只有比较变量或者单例时候，通常会使用‘is’。例如

    ```python
    if a is None:
    	...
    if b is not None:
    	...
    ```

    

- is 比 == 速度快

  - 由于is操作符不能重载，因此Python不需要浪费时间去寻找程序是否其他地方重载了比较操作符。is用于比较两个变量的id是否相同

  - ==操作符 相当于执行`__eq__()`，大部分数据类型都会重载这个函数，因此更耗时。（比如，当一个对象有N个属性，当判断是否相同时，需要对N个属性进行遍历，当然耗时）

- **不可变变量**，经过==或者is判断后并非一直不变

  例如元组是可以嵌套的，当tuple嵌套了list后，list进行修改后，那么元组本身就改变了。

  ```python
  t1 = (1, 2, [3, 4])
  t2 = (1, 2, [3, 4])
  t1 == t2
  True
  
  t1[-1].append(5)
  t1 == t2
  False
  ```





#### 浅拷贝与深拷贝



**浅拷贝：**重新分配一块内存空间，创建一个新的对象，**里面的元素是原对象中子对象的引用**。因此，<font color="red">**若原对象中的元素可变，那么浅拷贝会带来副作用**</font>。若原对象中的元素不可变，那么浅拷无影响。

**浅拷贝实现方法：**

- 数据类型本身的构造器：例如b = list(a), b = set(a), b = dict(a)等
-  对于可变的序列，可以采用切片进行浅拷贝，例如：l2 = l1[:]
- Python中提供函数，需要import copy进行，使用各种数据类型

```python
>>> a = ['123',[1,2]]
>>> b  = copy.copy(a)
>>> id(a)
2173248048264
>>> id(b)
2173248140424

>>> id(a[1])			#原列表中的列表元素与拷贝列表中的列表元素id相同
2173245926536
>>> id(b[1])			
2173245926536

>>> a[1].append(100)
>>> id(a)
2173248048264
>>> id(b)
2173248140424

>>> a					#对a的修改会影响到b的修改
['123', [1, 2, 100]]
>>> b
['123', [1, 2, 100]]

>>> id(b[1])			#修改后，原列表中的列表元素与拷贝列表中的列表元素id相同
2173245926536
>>> id(a[1])
2173245926536
```

可以看出，a的id与b的id并不一样，以此，虽然值是相同的但是是两块不同的内存空间。其中关键的是，a与b中的子列表是同一个引用，可以看到id(a[1])与id(b[1])是一样的。

![646ec9642018367ac3de8e95924571e.png](https://i.loli.net/2019/06/19/5d09e0647377872742.png)



- 需要注意的是，元组不会创建浅拷贝，只会创建一次。a,b同时指向这元组。

  ```python
  >>> a = ([1,2,3],'b','c')
  >>> import copy
  >>> b = copy.copy(a)
  >>> id(a)
  2173247924264
  >>> id(b)
  2173247924264
  >>> a == b
  True
  ```



浅拷贝存在的问题：

```python
>>>l1 = [[1, 2], (30, 40)]
>>>l2 = list(l1)
>>>l1.append(100)
>>>l1[0].append(3)

>>>l1
[[1, 2, 3], (30, 40), 100]

>>>l2
[[1, 2, 3], (30, 40)]

>>>l1[1] += (50, 60)
>>>l1
[[1, 2, 3], (30, 40, 50, 60), 100]

>>>l2
[[1, 2, 3], (30, 40)]
```

- l2没有100的原因：因为append是对l1对象进行的操作而并非l1内部元素，因此l2中并不会存在100。
- l2中有3的原因：这是因为l2中存在l1中list对象的引用，因此，改变l1中list的值，同样会改变l2中list的值。因为引用是的是同一个列表元素。.
- l2中没有(50,60)的原因：因为l1生成新的tuple并将新的引用作为l1中tuple的引用，而l2中仍然是旧元组的引用。





**深拷贝：**重新分配内存，创建一个新的对象，并且将原对象中的元素，**以递归地方式**，通过创建新的子对象拷贝到新对象中。因此，新对象与原对象没有任何关联。

**深拷贝实现方式：**b = copy.deepcopy(a)

无论a 如何变化，都不会影响到b。a,b完全独立。

影响：

- 当出现对自身的引用后，deepcopy后可能因为无限递归而报错





【提醒】

当对数值、字符串、仅包含数值/字符串的元组进行浅/深拷贝会失效。 也就是文中所提到的, 会返回一个指向相同数值、字符串、元组的引用~



https://i.loli.net/2019/06/19/5d09e0647377872742.png 我画了一个关于浅拷贝的理解。老师看是否合适？此外，求解答为什么会出现x的无限递归？还有为什么len(x)是2