

### 值传递与引用传递

**值传递：** 拷贝参数的值，然后传递给函数里面的新变量。这样原变量与新变量之间相互独立，互不影响。

​	对应的例子就是，通过swap函数交换，虽然函数内部交换了，但是返回后并不影响之前的值

```
void swap(int x, int y) {
int temp;
temp = x; // 交换 x 和 y 的值
 x = y;
 y = temp;
 return;
}
```

**引用传递：** 将参数的引用传给新的变量，这样，原变量与新变量会指向同一块内存地址，如果其中任意的一个变量的值改变，另一个变量的值也会随之改变。

​	对应的例子就是，通过swap函数交换，函数内部交换影响函数之外的值

```
void swap(int& x, int& y) {
   int temp;
   temp = x; // 交换 x 和 y 的值
   x = y;
   y = temp;
   return;
}
```



#### Python变量及赋值

```
a = 1
b = a
a = a + 1
```

- 变量a指向1
- 变量b和变量a都指向1。Python里的对象可以被多个变量所指或引用
- 变量a指向1，并加1，由于int，string类型等不可变，所以并不是让a的值增加1，而是内存重新创建一个新的值为2的对象，并让变量a指向它。
- 而变量b仍然指向1

【以上表明】

- b=a只是简单的赋值，并不表示重新创建新的对象，只是让一个对象被多个变量指向。
- 指向一个对象并不意味这两个变量被绑到一起，给其中一个重新赋值不会影响其他变量的值



```
l1 = [1, 2, 3]
l2 = l1
l1.append(4)
l1
[1, 2, 3, 4]
l2
[1, 2, 3, 4]
```

l1和l2同时指向了[1,2,3]这个对象，由于列表是可变的，所以l1.append(4)不会新建列表，所以，列表的变化l1和l2都可以看出来。



- Python中变量是可以删除，但是对象是无法删除的。

  ```
  l = [1, 2, 3]
  del l
  ```

  l表示的是变量，而[1,2,3]表示的是内存中创建的对象。del l表示删除变量，而内存中[1,2,3]列表仍然存在。只有当引用为0时，垃圾回收机制才会将改对象进行回收。

  

#### Python 函数的参数传递

根据Python官网手册：

>Remember that arguments are passed by assignment in Python.Since assignment just creates references to objects, there is no alias bewteen an argument name in the caller and callee.

<font color="red">Python的参数传递是**赋值传递**，或者叫做**对象的引用传递**。Python里所有的数据类型都是对象，所有参数传递时，只是让新变量与原变量指向相同的对象而已。不存在值传递或者引用传递。</font>



**思考1**：L1和L2都进行初始化，分配不同的内存空间，所以指向的不同对象，而L2和L3是赋值得到的，指向同一对象。

**思考2**：字典是可变的，所以提前猜测是可以改变为 {'a': 10, 'b': 20}的。
但是在突然想到文章中的list例子无返回也不能改变？
在例子中用到的是
    def func(l):
        l = l+[4]
d = [1,2,3]
func(d)
print(d)
这是创建了新的列表赋值给新的l，而不影响外面的d。
但是如果函数中是
    def func(l):
        l += [4]
或者
    def func(l):
        l.append(4)
由于l和d指向同一对象，而list可变，可以直接在列表末尾加上数字，所以不用返回也可以改变外面的值。list数据类型的+=操作符应该是重载了，实现效果和append一致。